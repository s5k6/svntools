#!/usr/bin/python

import os
import stat
import ConfigParser


def err(msg):
    print 'ERROR: %s' % msg
    exit(1)

def warn(msg):
    print 'WARNING: %s' % msg


groups = {}
perms = []



s = os.stat('access.d')
m = stat.S_IMODE(s[stat.ST_MODE])
if m & 0770 != 0770: err('Invalid mode %o: chmod 770 access.d' % m)


mySection = 'mkaccess override'


for repo in os.listdir('access.d'):
    conf = os.path.join('access.d', repo)

    s = os.stat(conf)
    m = stat.S_IMODE(s[stat.ST_MODE])
    if m & 0660 != 0660: err('Invalid mode %o: chmod 660 %s' % (m, conf))

    cp = ConfigParser.ConfigParser()
    cp.optionxform = str
    cp.read(conf)

    warnPrefix = True
    warnExternalGroup = True
    if cp.has_section(mySection):
        if cp.has_option(mySection,'warnPrefix'):
            warnPrefix = cp.getboolean(mySection,'warnPrefix')
        if cp.has_option(mySection,'warnExternalGroup'):
            warnExternalGroup = cp.getboolean(mySection,'warnExternalGroup')

    gs = {}
    if cp.has_section('groups'):
        gs = dict(cp.items('groups'))
        for (g, ms) in gs.iteritems():

            # check for sane prefix
            if warnPrefix and not(g.startswith(repo)):
                warn('Groupname `%s` does not start with repository '
                     'prefix `%s` in %s' % (g,repo,conf))

            # fail if group is redefined
            if groups.get(g) != None:
                err('Redefinition of group `%s` in %s' % (g,conf))

            # warn if non-locally defined group is referenced
            for m in ms.split(','):
                m = m.strip()
                if m[0] == '@':
                    m = m[1:]
                    if m == g: err('Cyclic definition of group `%s`'
                                   ' in %s' % (m, conf))
                    if warnExternalGroup and gs.get(m) == None:
                        warn('Reference to non-local group `%s` in '
                             'definition of group `%s` in %s' % (m,g,conf))
        # add group definitions
        groups.update(gs)


    for sect in cp.sections():
        
        if ['groups', mySection].__contains__(sect):
            # these have been handled above
            pass
        
        else:
            # all other sections must define paths in a repos
            rp = sect.split(':',1)
            if len(rp) < 2:
                err('Invalid section [%s] (no colon) in %s' % (sect,conf))
            if rp[0] != repo:
                err('Section [%s] refers to repository `%s` instead '
                    'of `%s` in %s' % (sect,rp[0],repo,conf))
            ps = cp.items(sect)
            if warnExternalGroup:
                for (u, rs) in ps:
                    if u[0] == '@':
                        u = u[1:]
                        if gs.get(u) == None:
                            warn('Reference to non-local group `%s` in '
                                 'permissions for `%s` in %s'
                                 % (u, sect, conf))
            # add permission section
            perms.append((sect,ps))



# Verify that all groups referenced in group definitions are defined,
# and that no cycles occur.
            
for (g, ms) in groups.iteritems():
    for m in ms.split(','):
        m = m.strip()
        if m[0] == '@':
            m = m[1:]
            if m == g: err('Cyclic definition of group %s' % m)
            if groups.get(m) == None:
                err('Reference to unknown group `%s` in definition '
                    'of group `%s`' % (m,g))

                
# Verify that all groups referenced in permission sections are defined.
                
for (sect, ps) in perms:
    for (u, rs) in ps:
        if u[0] == '@':
            u = u[1:]
            if groups.get(u) == None:
                err('Reference to unknown group `%s` in permissions '
                    'for `%s`' % (u, sect))


# make a backup


                

# compile output                
            
access = open('access', 'w')
access.write("""# DO NOT EDIT THIS FILE
#        ____                       __              ___ __  
#       / __ \____     ____  ____  / /_   ___  ____/ (_) /_ 
#      / / / / __ \   / __ \/ __ \/ __/  / _ \/ __  / / __/ 
#     / /_/ / /_/ /  / / / / /_/ / /_   /  __/ /_/ / / /_    _   _   _
#    /_____/\____/  /_/ /_/\____/\__/   \___/\__,_/_/\__/   (_) (_) (_)
#                                                                              
# Do not edit this file.  It is compiled from other files and will be
# overwritten next time!  See the README for more information.
# ----------------------------------------------------------------------

[groups]
""")

for (g, v) in groups.iteritems():
    access.write('%s = %s\n' % (g,v))

for (sect, ps) in perms:
    access.write('[%s]\n' % sect)
    for (g,rs) in ps:
        access.write('%s = %s\n' % (g,rs))

access.write("""
# ----------------------------------------------------------------------
# BEWARE: This file will be overwritten by a ganerating script!
""")
